package main

import (
	"crypto/tls"
	"flag"
	"fmt"
	"io"
	"net"
	"net/http"
	"net/http/httputil"
	"os"
	"strings"
	"time"

	"golang.org/x/net/http2"
)

func main() {
	keylog := flag.String("keylog", "ssl-keylog.txt", "File name to write NSS key log format log of TLS keys")
	flagParseWithRequiredArguments("url")
	url := flag.Arg(0)

	if err := httpWithKeylog(url, *keylog); err != nil {
		fmt.Fprintf(os.Stderr, "%s: %s\n", os.Args[0], err)
		os.Exit(1)
	}
}

func httpWithKeylog(url, keyLogFileName string) error {
	kl, err := os.OpenFile(keyLogFileName, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		return err
	}
	fmt.Fprintf(kl, "# SSL/TLS secrets log file, generated by go\n")

	client := http.Client{Transport: newTransportWithKeyLog(kl)}

	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		return err
	}
	if req.URL.Scheme != "https" {
		return fmt.Errorf("URL must start with https://")
	}
	fmt.Printf("Leaking TLS keys to %s\n----------------------\n", keyLogFileName)

	res, err := client.Do(req)
	if err != nil {
		return err
	}
	dump, err := httputil.DumpResponse(res, false)
	if err != nil {
		return err
	}
	fmt.Printf("%s[body not shown]\n", dump)
	return nil
}

// newTransportWithKeyLog initializes a HTTP Transport with KeyLogWriter
func newTransportWithKeyLog(keyLog io.Writer) *http.Transport {
	transport := &http.Transport{
		TLSClientConfig: &tls.Config{KeyLogWriter: keyLog, InsecureSkipVerify: true},

		// Copy of http.DefaultTransport
		Proxy: http.ProxyFromEnvironment,
		DialContext: (&net.Dialer{
			Timeout:   30 * time.Second,
			KeepAlive: 30 * time.Second,
			DualStack: true,
		}).DialContext,
		MaxIdleConns:          100,
		IdleConnTimeout:       90 * time.Second,
		TLSHandshakeTimeout:   10 * time.Second,
		ExpectContinueTimeout: 1 * time.Second,
	}
	if err := http2.ConfigureTransport(transport); err != nil {
		panic(err)
	}
	return transport
}

func flagParseWithRequiredArguments(args ...string) {
	for i := range args {
		args[i] = fmt.Sprintf("<%s>", strings.ToUpper(args[i]))
	}
	usageMsg := fmt.Sprintf("Usage: %s %s\n", os.Args[0], strings.Join(args, " "))
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, usageMsg)
		flag.PrintDefaults()
		os.Exit(1)
	}
	flag.Parse()
	if flag.NArg() != len(args) {
		flag.Usage()
	}
}
